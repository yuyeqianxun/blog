> GC：Garbage Collection

### GC做什么
- 找到内存空间中的垃圾。
- 回收垃圾，让程序员能再次利用这部分空间。

### 必备基础知识
- **堆(HEAP)** 是用于动态存放对象的内存空间而对象在JavaScript里面是引用类型，之前在我的另一篇博客有讲JavaScript的类型。
- **mutator**，这个词意思晦涩，在GC里面代表应用程序本身，我们暂且理解为mutator需要大量的内存。
- **allocator**，mutator将需要内存的申请提交到此，allocator负责从堆中调取足够内存空间供mutator使用。
- **活动对象/非活动对象**，代表通过mutator引用的对象，举个例子：
```js
var a = {name: 'bar'} // '这个对象'被a引用，是活动对象。
a=null; // ‘这个对象’没有被a引用了，这个对象是非活动对象。
```

### 常用GC算法
#### 引用计数
顾名思义，让所有对象实现记录下有多少“程序”在引用自己，让各对象都知道自己的“人气指数”。
```js
var a = new Object(); // 此时'这个对象'的引用计数为1（a在引用）
var b = a; // ‘这个对象’的引用计数是2（a,b）
a = null; // reference_count = 1
b = null; // reference_count = 0 
// 下一步 GC来回收‘这个对象’了
```
#### 优势
- **可即刻回收垃圾**，当被引用数值为0时，对象马上会把自己作为空闲空间连到空闲链表上，也就是说。在变成垃圾的时候就立刻被回收。
- **因为是即时回收**,那么‘程序’不会暂停去单独使用很长一段时间的GC，那么最大暂停时间很短。
- **不用去遍历堆里面的所有活动对象和非活动对象**
#### 劣势
- **计数器需要占很大的位置**，因为不能预估被引用的上限，打个比方，可能出现32位即2的32次方个对象同时引用一个对象，那么计数器就需要32位。
- **最大的劣势是无法解决循环引用无法回收的问题** 这就是前文中IE9之前出现的问题

> 该算法已经逐渐被 ‘标记-清除’ 算法替代，在V8引擎里面，使用最多的就是 **标记-清除算法**

### 标记清除算法
#### 步骤
- 标记阶段：把所有活动对象做上标记。
- 清除阶段：把没有标记（也就是非活动对象）销毁。

#### 标记阶段
![image](https://note.youdao.com/yws/public/resource/f09a208336f4d1412cfe17c54ae501c1/xmlnote/AE6A45F312844C99B1F567D1D6BFE9EF/BF6C1DE599F249A1A892D94DAB02BCDE/15659)
**根**可以理解成我们的全局作用域，GC从全局作用域的变量，沿作用域逐层往里遍历（对，是深度遍历），当遍历到堆中对象时，说明该对象被引用着，则打上一个标记，继续递归遍历（因为肯定存在堆中对象引用另一个堆中对象），直到遍历到最后一个（最深的一层作用域）节点。

![image](https://note.youdao.com/yws/public/resource/f09a208336f4d1412cfe17c54ae501c1/xmlnote/AE6A45F312844C99B1F567D1D6BFE9EF/C26E77ECAD95490592CA662F85015731/15658)
标记完成之后，就是这样的：

![image](https://note.youdao.com/yws/public/resource/f09a208336f4d1412cfe17c54ae501c1/xmlnote/AE6A45F312844C99B1F567D1D6BFE9EF/F01FC2FB30924E10A1B5EC0802787993/15660)

#### 清除阶段
遍历整个堆，**回收没有打上标记的对象**。
> 这里我们不细讲如何将获得的内存空间再分配的问题，这个地方有点类似磁盘管理或者内存管理，比如best-fit,First-fit，Worst-fit。以及碎片化问题的产生和解决方法。

这种方法可以解决循环引用问题，因为两个对象从全局对象出发无法获取。因此，他们无法被标记，他们将会被垃圾回收器回收。正如图：
![image](https://note.youdao.com/yws/public/resource/f09a208336f4d1412cfe17c54ae501c1/xmlnote/AE6A45F312844C99B1F567D1D6BFE9EF/655E32603EDB407DA52B70FF1299503E/15657)

**优势**：
- 实现简单，打标记也就是打或者不打两种可能，所以就一位二进制位就可以表示
- 解决了循环引用问题

**缺点**：
- 造成碎片化（有点类似磁盘的碎片化）
- 再分配时遍次数多，如果一直没有找到合适的内存块大小，那么会遍历空闲链表(保存堆中所有空闲地址空间的地址形成的链表）一直遍历到尾端

### 复制算法
复制算法配合这张图理解起来非常简单，就是只把某个空间的活动对象复制到其他空间。  

将一个内存空间分为两部分，一部分是From空间，另一部分是To空间，将From空间里面的活动对象复制到To空间，然后释放掉整个From空间，然后此刻将From空间和To空间的身份互换，那么就完成了一次GC。
![image](https://note.youdao.com/yws/public/resource/f09a208336f4d1412cfe17c54ae501c1/xmlnote/AE6A45F312844C99B1F567D1D6BFE9EF/F8E8526088F64C70935E3F6A45983DC9/15663)
